# Docker Compose Server Stack

A reproducible multi-app server stack for:
- Nginx reverse proxy (HTTP/HTTPS)
- ACME HTTP-01 + Certbot
- Laravel (PHP-FPM) for dev and prod (separate runtimes)
- Separate Node builder containers (Vite build) for dev/prod
- MySQL + Postgres
- n8n (optional, included)

## ⚠️ IMPORTANT: Using Docker Compose

**ALWAYS use the helper script** for docker compose commands:
```bash
./scripts/dc.sh [commands]
```

See [DOCKER_USAGE.md](./DOCKER_USAGE.md) for details and common commands.

## Goals
- Reproducible on a new server: clone → run installer → up.
- Versioned images (no `latest`).
- Same service set for local/dev/prod; differences via `.env` + compose overrides.
- App code lives in separate repos; this repo only mounts app folders from the host.

## Requirements
- Ubuntu 24.04
- DNS A records pointing to this server (prod/dev, optional n8n)
- Public app repo (recommended) to avoid SSH keys

## Quick start (minimal interaction)

### 1) Clone the stack repo
```bash
sudo mkdir -p /srv/docker
sudo chown -R $USER:$USER /srv/docker
cd /srv/docker
git clone https://github.com/YOUR_ORG/YOUR_STACK_REPO.git
cd YOUR_STACK_REPO
chmod +x scripts/*.sh
```

### 2) Provide settings (one file, no wizard)
```bash
cp .env.example .env.dev
nano .env.dev
```

### 3) Run installer (non-interactive)
```bash
./scripts/install.sh --env-file .env.dev
```

The installer will:
- install packages + Docker + Compose plugin (if missing)
- configure UFW (22/80/443)
- create required folders under `/srv`
- clone app repo to `/srv/apps/...` (if missing)
- render Nginx vhosts from templates (HTTP-only until certs exist)
- bring the stack up
- initialize MySQL dev/prod databases and users
- request certificates with Certbot, re-render HTTPS vhosts, and reload Nginx

## Deploy
```bash
./scripts/deploy.sh dev
./scripts/deploy.sh prod
```

## Health check
```bash
./scripts/health-check.sh --env-file .env.dev
```

## PHP + Composer images
- PHP-FPM is built locally from `docker/php-fpm/Dockerfile` (extensions: gd, intl, pdo_mysql, zip; base PHP 8.5.1).
- Composer runs in a separate container built from `docker/composer/Dockerfile` (same extensions as PHP-FPM).

## Optional: n8n
- Set `DOMAIN_N8N` to a real DNS name to enable the n8n vhost and certificate.
- Keep `N8N_BASIC_AUTH_*` enabled for initial access; installer generates secrets if left as `change-me`.
- Set `N8N_HOST`/`N8N_PROTOCOL` to match the public n8n URL (used for webhooks).

## Generatemedia App (Next.js + BullMQ)

The stack includes support for the **generatemedia** application - a Next.js web app with BullMQ worker for media generation tasks.

### Architecture
- **generatemedia_web**: Next.js app (port 3000), proxied via Nginx
- **generatemedia_worker**: BullMQ worker processing background jobs
- **redis**: Redis instance for BullMQ job queue
- **postgres**: Dedicated database (`generatemedia` user and DB)

### Configuration

**Stack environment variables** (in stack `.env.dev`):
```bash
DOMAIN_GENERATEMEDIA=generatemedia.jenyn.com
GENERATEMEDIA_APP_REPO=https://github.com/clear-stack-systems/generatemedia.git
GENERATEMEDIA_APP_PATH=/srv/apps/generatemedia/current
GENERATEMEDIA_DB_NAME=generatemedia
GENERATEMEDIA_DB_USER=generatemedia
GENERATEMEDIA_DB_PASS=change-me  # Auto-generated by installer
GENERATEMEDIA_PUBLIC_BASE_URL=https://generatemedia.jenyn.com
GENERATEMEDIA_REDIS_URL=redis://redis:6379
GENERATEMEDIA_API_KEY=change-me  # Auto-generated by installer
```

**App environment variables** (in `/srv/apps/generatemedia/current/.env`):
```bash
# Create from .env.example:
cd /srv/apps/generatemedia/current
cp .env.example .env
nano .env

# Required:
KIE_API_KEY=your-kie-ai-api-key-here
KIE_DEFAULT_MODEL=flux-1.1-pro
```

The app's `.env` file is loaded via `env_file` in docker-compose and contains app-specific API keys.

### DNS Setup
Point `generatemedia.jenyn.com` (A record) to your server's IP before running the installer.

### Installation

1. **Run the standard installer** (clones repo, creates DB, etc.):
```bash
./scripts/install.sh --env-file .env.dev
```

2. **Configure app environment** (API keys):
```bash
cd /srv/apps/generatemedia/current
cp .env.example .env
nano .env
# Set KIE_API_KEY and KIE_DEFAULT_MODEL
```

The installer will:
1. Clone the generatemedia repo to `/srv/apps/generatemedia/current`
2. Create the Postgres database and user
3. Render the Nginx vhost
4. Request TLS certificate via Certbot

### Deployment
```bash
./scripts/deploy-generatemedia.sh .env.dev
```

This will:
1. Pull latest code from the repo
2. Build the Next.js Docker image
3. Run Prisma migrations (if schema exists)
4. Start redis, generatemedia_web, and generatemedia_worker
5. Reload Nginx

### Monitoring
```bash
# Check running services
docker ps | grep generatemedia

# View web logs
docker logs -f generatemedia_web

# View worker logs
docker logs -f generatemedia_worker

# Check Redis
docker exec -it redis redis-cli PING
```

### Notes
- The generatemedia repo is currently empty - the build process handles this gracefully
- Both web and worker run from the same Docker image (different commands)
- The worker command is `npm run worker` (must be defined in package.json)
- Next.js must be configured with `output: "standalone"` in next.config.js for production builds

## Claude CLI Container

The stack includes a Claude CLI container for AI-assisted development and operations.

### Initial Setup

1. Set your Anthropic API key:
   ```bash
   docker exec -it claude_cli bash
   export ANTHROPIC_API_KEY="your-key-here"
   # Or add to ~/.bashrc for persistence
   echo 'export ANTHROPIC_API_KEY="your-key"' >> ~/.bashrc
   ```

2. Verify installation:
   ```bash
   docker exec -it claude_cli claude --version
   ```

### Usage

**Interactive Shell**:
```bash
docker exec -it claude_cli bash
```

**Direct Commands**:
```bash
docker exec -it claude_cli claude chat
```

**Using Helper Script**:
```bash
./scripts/claude.sh              # Open shell
./scripts/claude.sh chat         # Start chat
```

### Capabilities

The Claude CLI container can:
- Access all app code in `/srv/apps`
- Control other containers via docker socket
- Exec into other containers for inspection/modification
- Communicate with stack services via network
- Read compose configuration in `/stack`

### Common Workflows

**Inspect running services**:
```bash
docker exec -it claude_cli bash
docker ps
docker logs nginx
```

**Modify app code**:
```bash
docker exec -it claude_cli bash
cd /srv/apps/wwerp/dev/current
# Use claude CLI to make changes
```

**Exec into other containers**:
```bash
docker exec -it claude_cli bash
docker exec -it wwerp_php_dev bash
```

### Security Notes

- The Claude CLI container has Docker socket access (`/var/run/docker.sock`), providing root-equivalent access to the host
- Only authorized users with SSH/sudo access should use this container
- API keys should be set per-session; do not store them in .env files
- Changes to app code should be committed and reviewed

## Notes
- `.env.*` files are not committed; only `.env.example` is tracked.
- `nginx/sites` is generated at render time; example vhosts live as `*.conf.example`.
- MySQL uses one container; dev/prod databases and users are created from `MYSQL_*_DEV/PROD` in `scripts/init-mysql.sh`.
- Nginx serves static assets from host-mounted app paths (`APP_PATH_DEV` -> `/var/www/app_dev`, `APP_PATH_PROD` -> `/var/www/app_prod`), while PHP-FPM reads code from `/var/www/app`.

---

## Permissions and Ownership

The stack follows a strict permission model for security and reproducibility:

### Ownership Rules
- **Stack repo** (`/srv/docker/stack-vps-multiapp`): `ben:ben` (deploy user)
- **App code** (`/srv/apps/*`): `ben:ben` (deploy user)
- **Letsencrypt** (`/srv/letsencrypt`): `root:root` (secure certificates)
- **Docker socket** (`/var/run/docker.sock`): `root:docker` with 660

### Deploy User Requirements
The deploy user (e.g., `ben`) must:
1. Be in the `docker` group (to control containers)
2. Own the stack repo and apps folder (to deploy code)
3. Have sudo access for system operations (firewall, package install)

### Fixing Permissions

If permissions get messed up (e.g., files owned by root after sudo operations):
```bash
sudo ./scripts/fix-permissions.sh ben
```

This script will:
- Set correct ownership on all key directories
- Make scripts executable
- Add deploy user to docker group
- Secure certificate private keys

After running, activate the docker group:
```bash
newgrp docker
# Or re-login to SSH
```

---

## RUNBOOK: Generatemedia Integration

### Prerequisites

1. **DNS**: Point `generatemedia.jenyn.com` A record to server IP

2. **Stack Environment**: Copy `.env.example` to `.env.dev` and configure:
   ```bash
   cp .env.example .env.dev
   nano .env.dev
   ```

   Set the following variables:
   ```bash
   DOMAIN_GENERATEMEDIA=generatemedia.jenyn.com
   GENERATEMEDIA_APP_REPO=https://github.com/clear-stack-systems/generatemedia.git
   GENERATEMEDIA_APP_PATH=/srv/apps/generatemedia/current
   GENERATEMEDIA_DB_NAME=generatemedia
   GENERATEMEDIA_DB_USER=generatemedia
   GENERATEMEDIA_DB_PASS=change-me  # Will be auto-generated
   GENERATEMEDIA_PUBLIC_BASE_URL=https://generatemedia.jenyn.com
   GENERATEMEDIA_REDIS_URL=redis://redis:6379
   GENERATEMEDIA_API_KEY=change-me  # Will be auto-generated
   REDIS_IMAGE=redis:7-alpine
   GENERATEMEDIA_IMAGE=stack-generatemedia:latest
   ```

3. **App Environment**: After cloning, configure the app's `.env`:
   ```bash
   # This is done AFTER the installer clones the repo
   cd /srv/apps/generatemedia/current
   cp .env.example .env
   nano .env
   ```

   Required app variables:
   ```bash
   KIE_API_KEY=your-kie-ai-api-key-here
   KIE_DEFAULT_MODEL=flux-1.1-pro
   ```

### Initial Installation

Run the standard installer (includes generatemedia setup):
```bash
./scripts/install.sh --env-file .env.dev
```

This will:
- Clone generatemedia repo to `/srv/apps/generatemedia/current`
- Create Postgres database and user
- Generate secrets (GENERATEMEDIA_DB_PASS, GENERATEMEDIA_API_KEY)
- Render Nginx vhost
- Request TLS certificate

### Manual Database Initialization (if needed)

If Postgres is already running and you need to add the generatemedia DB manually:
```bash
docker exec -it postgres psql -U app -d app -c "CREATE DATABASE generatemedia;"
docker exec -it postgres psql -U app -d app -c "CREATE USER generatemedia WITH PASSWORD 'your-password-here';"
docker exec -it postgres psql -U app -d app -c "GRANT ALL PRIVILEGES ON DATABASE generatemedia TO generatemedia;"
```

Or restart Postgres to trigger the init script:
```bash
./scripts/dc.sh restart postgres
```

### Deploy Generatemedia

```bash
./scripts/deploy-generatemedia.sh .env.dev
```

### Validation Commands

```bash
# Check compose config is valid
./scripts/dc.sh config

# Verify all services are running
docker ps | grep -E "(redis|generatemedia)"

# Expected output:
# redis          running
# generatemedia_web    running
# generatemedia_worker running

# Check Nginx config
docker exec nginx nginx -t

# Test HTTPS endpoint
curl -I https://generatemedia.jenyn.com

# Expected: HTTP/2 200 or 502 (502 = Nginx OK, app not responding yet)

# Check logs
docker logs generatemedia_web --tail 50
docker logs generatemedia_worker --tail 50
docker logs nginx --tail 50

# Check Redis connectivity
docker exec -it redis redis-cli PING
# Expected: PONG

# Verify database connection from web container
docker exec -it generatemedia_web sh -c 'echo $DATABASE_URL'
# Expected: postgresql://generatemedia:xxx@postgres:5432/generatemedia
```

### Troubleshooting

**Build fails (empty repo):**
```bash
# This is expected if the repo is empty
# The Dockerfile handles this gracefully
# Deploy will succeed but containers won't start
docker logs generatemedia_web
```

**502 Bad Gateway:**
```bash
# Check if web container is running
docker ps | grep generatemedia_web

# Check web logs
docker logs generatemedia_web

# Check if Next.js is listening on port 3000
docker exec generatemedia_web netstat -ln | grep 3000
```

**Database connection issues:**
```bash
# Verify DB exists
docker exec postgres psql -U app -d app -c "\l" | grep generatemedia

# Test connection from web container
docker exec -it generatemedia_web sh
# Then inside container:
# npm run db:migrate (if using Prisma)
```

**Certificate issues:**
```bash
# Re-request certificate manually
docker compose run --rm certbot certonly --webroot \
  --webroot-path=/var/www/certbot \
  --email admin@jenyn.com \
  --agree-tos \
  --no-eff-email \
  -d generatemedia.jenyn.com

# Re-render Nginx vhosts
./scripts/render-nginx.sh .env.dev
./scripts/dc.sh restart nginx
```

### Redis Queue Monitoring

```bash
# Connect to Redis CLI
docker exec -it redis redis-cli

# Inside Redis CLI:
KEYS *               # List all keys
LLEN bull:queue_name:wait  # Check queue length
LRANGE bull:queue_name:wait 0 -1  # List pending jobs
```

### Updating the App

```bash
# Pull latest code and redeploy
./scripts/deploy-generatemedia.sh .env.dev

# Or manually:
cd /srv/apps/generatemedia/current
git pull origin main
docker compose build generatemedia_web
docker compose up -d generatemedia_web generatemedia_worker
```

### Stopping Services

```bash
# Stop generatemedia only
./scripts/dc.sh stop generatemedia_web generatemedia_worker

# Stop everything
./scripts/dc.sh down
```

---

## Lessons Learned

### Adding New Applications to the Stack

Important insights from integrating Next.js + Prisma applications:

#### 1. Next.js Docker Image Requirements

**Always create the `public` directory:**
```dockerfile
# Even if empty, Next.js requires this directory
RUN mkdir -p /app/public
```
Without this, Next.js build fails in production.

**For workers (tsx/ts-node), copy source files:**
```dockerfile
# Workers using tsx need source files and node_modules
COPY --from=builder /app/src ./src
COPY --from=builder /app/node_modules ./node_modules
```

#### 2. Prisma ORM Requirements

**Use Debian-based Node image, not Alpine:**
```dockerfile
# ✅ Correct: Debian-based
FROM node:20-slim

# ❌ Wrong: Alpine (Prisma needs glibc)
FROM node:20-alpine
```
Prisma requires glibc (GNU C Library), which Alpine doesn't have (uses musl).

**Install OpenSSL in runtime image:**
```dockerfile
RUN apt-get update -y && apt-get install -y openssl && rm -rf /var/lib/apt/lists/*
```
Prisma requires libssl at runtime.

**Copy Prisma schema for migrations:**
```dockerfile
COPY --from=builder /app/prisma ./prisma
```
Needed to run `npx prisma migrate deploy` in production.

#### 3. Environment Variable Strategy

**Separate stack and app environments:**

- **Stack `.env.dev`**: Infrastructure (DB URLs, domains, paths)
  - Safe to have `.env.example` in git
  - Contains auto-generated secrets (DB passwords)

- **App `.env`**: Application-specific (API keys)
  - Loaded via `env_file` in docker-compose
  - Never committed to any repo
  - Each app manages its own secrets

**Why separate:**
- Stack can be cloned without exposing app secrets
- App secrets stay in app repo (or separate secure storage)
- Infrastructure variables are documented in stack `.env.example`

#### 4. Nginx Certificate Detection

**Check certificates from inside the nginx container:**
```bash
# ✅ Correct
docker exec nginx test -f /etc/letsencrypt/live/${DOMAIN}/fullchain.pem

# ❌ Wrong
test -f /srv/letsencrypt/conf/live/${DOMAIN}/fullchain.pem
```
Host filesystem paths may differ from container view.

#### 5. BullMQ Workers

**Run as separate container with same image:**
```yaml
myapp_worker:
  image: ${MYAPP_IMAGE}  # Same as web
  command: ["npm", "run", "worker"]  # Different command
```

**Worker needs:**
- Redis connection
- Database access
- Same environment variables as web
- Dependency on web service (for startup order)

#### 6. Docker Compose Helper Script

**ALWAYS use `./scripts/dc.sh` instead of `docker compose`:**
```bash
# ✅ Correct
./scripts/dc.sh up -d

# ❌ Wrong (recreates containers without volumes)
docker compose up -d
```

The helper script ensures correct env files and compose files are loaded.

#### 7. Multi-Stage Docker Builds

**Pattern for Next.js:**
1. **deps** - Install dependencies
2. **builder** - Build application
3. **runner** - Minimal runtime image

**Benefits:**
- Smaller final image
- Cached dependency layer
- Separates build-time and runtime dependencies

#### 8. Health Checks

**Add health checks for critical services:**
```yaml
services:
  myapp_web:
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

Helps Docker Compose detect when services are ready.

### Common Pitfalls to Avoid

1. **Using `latest` tags** - Always pin versions
2. **Hardcoding domains** - Use environment variables
3. **Committing secrets** - Use `.env` files (gitignored)
4. **Skipping health checks** - Prevents cascade failures
5. **Running docker compose directly** - Use `./scripts/dc.sh`
6. **Alpine for Prisma apps** - Use Debian instead
7. **Missing public directory** - Next.js requires it
8. **Forgetting OpenSSL** - Prisma needs it at runtime

### Best Practices

1. **Version everything** - Images, packages, dependencies
2. **Document everything** - README, CHANGELOG, AGENTS.md
3. **Test before commit** - `./scripts/dc.sh config`
4. **Use templates** - Nginx vhosts, Dockerfiles
5. **Separate concerns** - Infrastructure vs application
6. **Fail fast** - `set -euo pipefail` in all scripts
7. **Be idempotent** - Scripts safe to re-run
8. **Ask before push** - Always get user approval

---

For detailed guidelines on working with this stack, see [AGENTS.md](./AGENTS.md).
